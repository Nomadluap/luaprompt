luaprompt

Copyright (C) 2012-2015 Dimitris Papavasileiou <dpapavas@gmail.com>

luaprompt is both an interactive Lua prompt that can be used instead
of the official interpreter, as well as a simple library that provides
a Lua command prompt that can be embedded in a host application.  As a
standalone interpreter it provides many conveniences that are missing
from the official Lua interpreter.  As an embedded prompt, it's meant
for applications that use Lua as a configuration or interface language
and can therefore benefit from an interactive prompt for debugging or
regular use.

luaprompt features:

* Readline-based input with history and completion: In particular all
  keywords, global variables and table accesses (with string or
  integer keys) can be completed in addition to readline's standard
  file completion.  Module names are also completed, for modules
  installed in the standard directories, and completed modules can
  optionally be loaded.

* Persistent command history (retained across sessions).

* Proper value pretty-printing for interactive use: When an expression
  is entered at the prompt all returned values are printed (prepending
  with an equal sign is not required).  Values are printed in a
  descriptive way that tries to be as readable as possible.  The
  formatting tries to mimic Lua code (this is done to minimize
  ambiguities and no guarantees are made that it is valid code).
  Additionally, each value is stored in a table for future reference.

* Color highlighting of error messages and variable printouts.

Embedded Usage
==============

To embed luaprompt into a host application simply compile and link
prompt.c with your sources.  A POSIX environment is assumed and
readline is required for proper command line editing.  If readline is
provided you should define the macros HAVE_LIBREADLINE and either
HAVE_READLINE_READLINE_H or HAVE_READLINE_H depending on where your
readline's header files are installed.  Similar macros are required
for command line history support.  See the example Makefile for
details.

The API is very simple:

void luap_enter (lua_State *L)
Call this to begin an interactive session.  The session can be
terminated with Ctrl-D.

void luap_setname (lua_State *L, const char *name)
Set the name of the application.  This is basically the chunk name
displayed with error messages.  The default program name is "lua".

void luap_setprompts (lua_State *L, const char *single, char *multi)
Provide two prompts, one for single-line and one for multi-line
input. The defaults prompts are "> " and ">> ".

void luap_sethistory (lua_State *L, const char *file) Set the file to
be used to perist the command history across sessions.  If this
function isn't called the command history is lost on session exit.
Note that the provided name is used as-is, that is, it is not expanded
as if it was entered at the shell so you cannot use a string of the
form "~/.lua_history" for example.

void luap_setcolor (lua_State *L, int enable)
Setting enable to zero disables color output.  Color output is enabled
by default if the output has not been redirected to a file or pipe.

There are also matching luap_get* calls, which work much like you'd
expect them to:

void luap_getprompts(lua_State *L, const char **single, const char **multi)
void luap_gethistory(lua_State *L, const char **file)
void luap_getcolor(lua_State *L, int *enabled)
void luap_getname(lua_State *L, const char **name)

In addition to the above the following calls, which are meant for
internal use can be used by the host applicaton as well if required.

char *luap_describe (lua_State *L, int index)
Returns a string with a human-readable serialization of the value at
the specified index.

int luap_call (lua_State *L, int n)
Calls a function with n arguments and provides a stack trace on error.
This is equivalent to calling lua_pcall with LUA_MULTRET.

The prompt module
=================

luaprompt is also available as a Lua module.  Using it is pretty
straightforward, as it essentially wraps the calls described above,
either in variables which can be set or queried, or in Lua functions.
An example session follows:

> prompt = require "prompt"
> prompt.colorize = true
> prompt.name = "myprompt"
> prompt.history = "/tmp/.myprompt_history"
> prompt.prompts = {"%  ", "%% "}
> prompt.enter()
%   _G[nil] = 
%% nil
myprompt:2: table index is nil

Stack trace:
	#0 [C]: in function '__newindex'
	#1 myprompt:2: in the main chunk
	#2 [C]: in function 'enter'
	#3 stdin:1: in the main chunk
	#4 [C]: in function ?

% ^D 
>

One can also use just the pretty-printer of luaprompt, by calling
prompt.describe, which returns a string with a pretty print-out of the
argument.  For example:

> =prompt.describe(coroutine)
{ 
  create = <function: 0x41a8b0>,
  yield = <function: 0x41a630>,
  wrap = <function: 0x41a910>,
  running = <function: 0x41a890>,
  resume = <function: 0x41a9e0>,
  status = <function: 0x41a770>,
}

Standalone usage
================

Although luaprompt is meant for embedded use, a standalone interpreter
has also been written. It tries to mimic the standard lua interepreter
as much as possible (currently only the -E flag is not supported)
while providing the extra set of features described above.  Some
tweaking of the makefile may be required to get it to build.

Configuration
=============

Some aspects of luaprompt's behavior are configurable at compile time.
Please consult the supplied Makefile for the available options and
their explanations.

License
=======

luaprompt is released under the terms and conditions of the MIT/X11
license.
